# Particle Filter Project
## Team: Kiana Hobbs, Elizabeth Singer
## Implementation
### Initialize Particle Cloud
How you will initialize your particle cloud (initialize_particle_cloud()):
</br>
Given a map of the room, we will randomly pick particles inside the house, while verifying that it’s a place where the robot could be using the free threshold of 0.196. If the particle is in a valid location, we will randomly pick the orientation between 0 and 360 degrees, else we will try again until we create n particles at valid locations. 
</br></br>
To test this function, we will first make sure that we can determine a point on the map at random, and check that the point is a valid placement. We will then test that we can generate a few such points. We can inspect these in Gazebo using rviz.

### Particle Positions Update
How you will update the position of the particles will be updated based on the movements of the robot (update_particles_with_motion_model()):
</br>
We will monitor the odometry messages and apply the twist messages, which have the velocities, to each particle over the time since the last update. We can also include small random perturbations to each particle position to allow them to drift.
</br></br>
We will verify that we can observe the twist messages from the odometry and print these to the log. We will then verify that we can apply the motion from a twist message to a single particle and observe the change in both logs and on Gazebo. Then we will observe that we can apply the motion to all of the particles as the simulation progresses. 

### Importance Weights
How you will compute the importance weights of each particle after receiving the robot's laser scan data (update_particle_weights_with_measurement_model()):
</br>
For each particle, k=1..N, we will compute what the laser scan data would be if the robot were at that location and orientation, scan(k,theta). We may do this for just one theta, being the direction to the closest object in the map, or for all theta. We will then compute the sum of the squares of the errors between the hypothetical laser scan, scan(k,theta) and the true laser scan, scan_true(theta) for the thetas considered and call this the particle sensor error e_k = sum (scan(k,theta)-scan_true(theta))^2, over all theta’s considered, or just for the closest direction to the closest object. Then each particle weight, w_k can be updated using this particle sensor error. One way to do this is to simply make each particle new weight just equal to the inverse of this sensor error w_k = 1/e_k.  Another approach would be to update each weight proportional to this error, so w_k_new = w_k_old / e_k, or w_k_new = w_k_old * G(e_k,sigma), where G(e,sigma) is the Gaussian distribution with variance sigma^2, G(e,s) = (1/sqrt(2 pi s)) exp(-e^2/(2 s^2)). 
</br></br>
To test, we will generate some laser scans by hand, and verify that the weight update calculation is correct for these hand-calculations. We will then generate laser scans from gazebo, and add fixed errors to these, and compute the weights that come from these, then we will generate scans from random particle locations. We will test this hypothetical laser scan function separately first to verify that it provides the correct scan data, which we can do by placing the robot in that location and comparing the hypothetical scan with the scan from the messages in ros.

### Normalization and Resampling
How you will normalize the particles' importance weights (normalize_particles()) and resample the particles (resample_particles()):
</br>
To normalize the particle’s importance weights we will calculate the sum of all the weights (sum w_k, k=1..N) and divide each particle weight by the sum of the weights so that each one will add to one, W=sum(w_k), w_k_new = w_k / W. (Divide each weight by the sum of the weights). To resample the particles, there are a few ways to do this. One way is to use the draw_random_sample function provided in the code, which just selects N particles at random from the given particle list and their weights. Another way would be to look at the particles that have small weights, below some threshold value, and replace these particles with new particles, drawn at random using the draw_random_sample function given in the code. This way, particles with larger weights will remain, and particles that become negligibly small in probability will be replaced with more likely particles. 
</br></br>
For this function, we can test normalizing weights by first running this on some fixed weights generated by hand, and verifying they are correct. Then we can generate large sets of weights and normalize them and see that they still sum to 1. We can test resampling by making sure that for a small number of particles, that the resampling function throws away particles that are below the threshold and picks new particles that have high probabilities. 

### Pose Estimation
How you will update the estimated pose of the robot (update_estimated_robot_pose()):
</br>
We will use the expected value of the pose, given the distribution obtained from the particles. To compute this, we will add up the weighted sum of the poses, p_k, weighting them by their weights w_k, so that p_estimate = sum p_k w_k over all of the particles k=1..N. We will weigh each pose of each particle by it’s probability (weight) and just add them all up. Another way to do it would be to select the one the particle that has the highest weight (which is most likely the correct pose) and use that as our estimate. A hybrid between these two is to use the weighted sum of poses from all of the particles within some distance of the highest probability particle and take the weighted average of the poses of those particles. The third option is likely the best. 
</br></br>
We can calculate by hand and then look at it and make sure it looks accurate to the hand calculations. We can check that the most likely particle selection works by inspecting these by hand, and we can check that the hybrid works similarly.

### Noise
How you will incorporate noise into your particle filter.
</br>
There are a few ways we can incorporate noise into our particle filter. The first is that we can include noise in our motion update model, where we update the pose of each particle using not only the velocities from the odometry messages, but we also include some random drifts in the positions. This way, when we do resampling with replacement, if particles are selected multiple times, then these particles will drift away from each other, making more particles close to each other, to let us explore the space better. Another way we can incorporate noise into our model is to use a model, like the gaussian model, that updates the weights of the particles according to the formula for a gaussian, p(e_k) = (1/sqrt(2 pi sigma)) exp(-e_k^2 / 2 sigma^2), where sigma^2 is the variance of the gaussian. This will let us assume that the sensor returns are noisy returns. Another way we can incorporate noise into our particle filter is that we can choose to not only throw away particles that have almost zero weight, but we can also throw away particles with some probability that is a function of its weight, so that low weight particles are removed with much higher probability than high weight particles.
</br></br> 
We already mentioned that we will test the motion model noise by first setting the noise to be zero, and verifying that the particles move according to the twist messages, then using small noise to the motion, verifying that the particles are close to the zero noise case. For   resampling we can verify that only low probability particles are thrown away and that the number of high probability particles is much higher than those of lower probability. We will test each function separately before incorporating them into larger functions.


## Timeline
By February 2nd, we plan to finish the following functions: initialize_particle_cloud(), update_particles_with_motion_model(), and update_particle_weights_with_measurement_model(). Moreover, by February 9th, we finish the remaining functions: resample_particles(), normalize_particles(), and update_estimated_robot_pose().